PostgreSQL由5大部分组成：连接管理系统、编译执行系统、存储管理系统、事务系统、系统表。
连接管理系统:接受外部操作对系统的请求，对操作请求进行预处理和分发，起系统逻辑控制的作用
编译执行系统由查询编译器、查询执行器组成，完成操作请求在数据库中的分析处理和转化工作，最终实现物理存储介质中数据的操作
存储管理系统由索引管理器、内存管理器、外存管理器组成，负责存储和管理物理数据，提供对编译查询系统的支持
事务系统由事务管理器、日志管理器、并发控制、锁管理器组成，日志管理器和事务管理器完成对操作请求处理的事务一致性支持，锁管理器和并发控制提供对并发访问数据的一致性支持
系统表是PostgreSQL数据库的元信息管理中心，包括数据库对象信息和数据库管理控制信息。系统表管理元数据信息，将PostgreSQL数据库的各个模块有机的连接在一起，形成一个搞笑的数据管理系统。


2.1系统表
	系统表扮演着数据字典的角色。
	每一个数据库都有一套自己的系统表，其中大多数系统表都是在数据库创建时从模板数据库中拷贝过来的。只有少数系统表是所有数据库共享的（比如：pg_database）,这些表里的数据时关于所有数据库的。

2.1.1 主要的系统表功能及依赖关系

	1.pg_namespace
	用于存储命名空间
	名字空间层次：数据库.模式.表.属性。
	每一个元组都对应一个名字空间，每一个名字空间对应一个OID。

	2.pg_tablespqce
	存储表空间信息。所有的数据库共享一个pg_tablespqce表
	用处：第一，当分区或卷空间已用光，可以通过表空间去利用另一个分区的空间；第二，允许管理员根据数据库对象的使用模式安排数据位置，从而优化性能。
	每一个元组都对应一个表空间，每一个表空间都被分配一个OID。

	3.pg_database
	存放当前数据集簇中数据库的信息，在整个集簇范围内共享的系统表。每一个元组表示集簇中的一个数据库，每一个数据库都被分配一个OID。

	4.pg_class
	存储表及表类似结构的数据库对象信息，包含索引、序列、视图、复合数据类型、TOAST表。每一个对象都在pg_class中表现为一个元组，每一个对象都被分配一个OID。

	5.pg_type
	存储数据类型信息。基本数据类型由CREATE TYPE创建，域类型由CREATE DOMAIN创建，复合数据类型在表创建时自动创建。pg_type中的每一个元组对应一个数据类型。
	
	6.pg_attribute
	存储表的属性信息，对于数据库中表的每个属性都有一个元组。

	7.pg_index
	存储索引的具体信息。

2.1.2 系统视图
	内置的视图，初始化数据库集簇的时候读取脚本创建的。系统视图提供了查询系统表和访问数据库内部状态的方法。
	系统表是PostgreSQL数据库系统运行控制信息的来源，是数据库系统的核心组成部分。虽然用户可以操作，但为维护系统表信息的一致性，系统表将由系统统一维护。

2.2 数据库集簇
	PostgreSQL安装完成之后，必须先使用initdb程序初始化磁盘上的数据库存储区，即数据库集簇，由PostgreSQL管理的用户数据库以及系统数据库总称为数据库集簇。PostgreSQL的所有数据都存储在其数据目录里，这个数据目录用环境变量PSDATA来引用，PGDATA代指数据目录。
	
	OID用来在整个数据库中唯一的标识一个数据对象，这个对象可以说是数据库、表、索引、视图、元组、类型等。PostgreSQL提供了Oid数据类型来表示OID，它实际上是一个无符号整数。

	初始化数据集簇包括创建包含数据库系统所有数据的数据目录、创建共享的系统表、创建其他的配置文件和控制文件，并创建3个数据库：模板数据库template1和template0、默认的用户数据库postgres。以后用户穿件一个新数据库时，template1数据库的所有内容（包括系统表文件）都会拷贝过来，因此任何在template1里面安装的内容都自动拷贝到之后创建的数据库中。template0和postgres都是通过拷贝templ1创建的。

2.2.1 initdb的使用

2.2.2 postgres.bki

2.2.3 initdb的执行过程

2.2.4 系统数据库

2.3 PostgreSQL进程结构
	PostgreSQL系统的主要功能都集中在postgres程序，其入口是Main模块中的main函数。
	PostgreSQL使用一种专用的服务器进程体系结构，最主要的两个进程就是守护进程Postmaster和服务进程Postgres。从本质上来说，
	PostgreSQL系统几乎所有核心功能都是由postgres程序完成的。

2.4 守护进程Postmaster
	Postmaster是一个处理客户端请求的调度中心。

2.4.1 初始化内存上下文
	可以通过释放内存上下文来避免内存泄露

2.4.2 配置参数
	在初始化内存环境之后需要配置Postmaster运行时所需的各种参数。GUC模块实现了多种数据类型的变量配置
	参数有6中类型，通过枚举类型GucContext定义，只能在合适的环境下进行配置
	每一种数据类型的GUC参数都有两部分组成：共性部分和特性部分。每一种具体的数据类型都有其特性的数据结构，该结构中的第一项都是指向其共性数据结构的指针。
	1、初始化GUC参数：先统计参数个数，分配指针；将每个参数设置为默认值；调用getenv来或得环境变量；检查系统最大安全栈深度。
	2、配置GUC参数
	3、读取配置文件

2.4.3 创建监听套接字

2.4.4 注册信号处理函数
	进程有权选择相应或屏蔽信号（SIGKILL和SIGSTOP不能屏蔽）。Postmaster定义了三个信号集：BlockSig是要屏蔽的信号集；UnBlockSig是不希望被屏蔽的信号集；AuthBlockSig是在用户进行连接认证时需要屏蔽的信号集，它们都是位向量。
	在设置响应信号的处理函数前，要通过PG_SETMASK函数把这些信号全部屏蔽，然后通过pqsignal函数为感兴趣的信号设置处理函数。
	1、信号处理函数SIGHUP_handler
	配置文件发生改变时产生SIGHUP信号。Postmaster进程收到该信号时，重新读取配置文件postgresql.conf，然后向子进程发出同样的信号，并重新装载pg_hba.conf和pg_ident.conf文件。
	2、信号处理函数pmdie
	pmdie处理三种信号：SIGTERM、SIGINT和SIGQUIT。三种信号分别对应三种不同的系统关闭方式
	3、信号处理函数reaper
	当有子进程退出时，子进程会给Postmaster发送一个SIGCHLD信号。Postmaster收到该信号后调用reaper函数清理退出的子进程。

2.4.5 辅助进程启动
	在Postmaster的创建过程中首先会启动SysLogger日志进程，并完成PgStat进程、AutoVacuum进程的初始化工作，而在Postmaster的监听循环中检测辅助进程的状态，并创建或者重新创建这些辅助进程。
	1、SysLogger辅助进程
	Postmaster调用SysLogger_Start函数启动SysLogger子进程。该子进程通过管道从各进程中收集所有stderr输出，并将这些输出写入到日志文件中。
	2、辅助进程的初始化
	
2.4.6 装载客户端认证文件
	注册完信号处理函数后，将逐行读取data目录下的pg_hba.conf和pg_ident.conf两个配置文件的内容到链表变量中，以用于控制客户端认证。
	其中，pg_hba.conf是基于主机认证的配置文件。
	pg_ident.conf是基于身份认证的配置文件。

2.4.7 循环等待客户连接请求
	PostgreSQL系统采用C/S模式，系统为每个客户端分配一个后台服务进程Postgres。
	服务进程叫Postgres

2.5 辅助进程

2.5.1 SysLogger系统日志进程
	该进程入口位置为SysLogger_Start函数，最后调用SysLoggerMain函数真正进入日志进程的运行。

2.5.2 BgWriter后台写进程
	该进程是PostgreSQL中在后台将脏页写出到磁盘的辅助进程。引入该进程的目的：首先如果要读取的数据不再缓冲区要先从磁盘读入要读取的数据所在的页面，如果此时缓冲区已满，则需要先将部分缓冲区页面替换出去。如果被替换的页面没有被修改过，则这些页面可以直接丢弃；如果被修改过，则需要将这些页面写出到磁盘后才能替换。其次，PostgreSQL在定期作检查点时需要将所有脏页写出到磁盘，通过BgWriter预先写出一些脏页，可以减少设置检查点是要进行的IO操作，使系统的IO趋于平稳。
	BgWriter辅助进程在Postmaster中启动，入口为StartBackgroundWriter函数，BgWriter和WalWriter采用相同的模式启动。BgWriter实际工作的函数是BackgroundWriterMain。
	BgWriter后台进程最理想的情况是后台写进程负责刷回所有的缓冲区，但是如果后台写进程不能保证有足够多干净的缓冲区情况下，常规后台进程仍然有权刷回缓冲区。

2.5.3 WalWriter预写式日志进程
	WAL（Write Ahead Log，也称为Xlog）的中心思想是对数据文件的修改必须是发生在这些修改已经记录到日志之后，也就是先写日志后写数据。
	WalWriter辅助进程在Postmaster中启动，启动函数为StartWalWriter，WalWriter的实际工作函数为WalWriterMain。

2.5.4 PgArch预写式日志归档进程
	该进程作用是对WAL日志日志在磁盘上的存储形式进行归档备份。
	PostgreSQL会在数据集簇的pg_xlog/archiver_status目录下记录每一个WAL文件的状态，状态文件的前缀与段文件同名，以表示时间顺序的整数命名。后缀为.ready或者.done。
	PgArch进程在工作循环中检测到需要进行归档时会找到所有“就绪”的WAL段文件，然后对其进行归档。完成一次归档之后，PAArch将休眠直至下一次需要归档时。

2.5.5 AutoVacuum系统自动清理进程
	在PostgreSQL数据库中，对表元组的UPDATE或DELETE操作并未立即删除旧版本的数据，表中的旧元组只是被标识为删除状态，并未立即释放空间。AutoVacuum进程，自动执行VACUUM和ANALYZE命令，回收被标示为删除状态记录的空间，更新表的统计信息。
	AutoVacuum进程中包含两种不同的处理进程：AutoVacuum Launcher和AutoVacuum Worker。AutoVacuum Launcher为监控进程，AutoVacuum Worker进程执行实际的清理任务。

2.5.6 PgStat统计数据收集进程
	该进程是PostgreSQL数据库系统的统计信息收集器，专门负责收集数据库系统中的统计信息。
	该进程收集的统计信息主要是用于查询优化时的代价估算。


2.6 服务进程Postgres
	Postgres进程是实际接受查询请求并调用相应模块处理查询的PostgreSQL服务进程。它知己接受用户的命令进行编译执行，并将结果返回给用户。

2.6.1 初始化内存环境
	Postgres进程有两种运行方式。多用户模式下被Postmaster动态创建，则这部分工作由Postmaster来完成，在Postgres进程中此部分跳过。

2.6.2 配置运行参数和处理客户端传递的GUC参数
	多用户模式下由Postmaster完成，单用户模式下和Postmaster完全相同。

2.6.3 设置信号处理和信号屏蔽
	SIGHupHandler：配置文件发生改变时产生此信号。
	StatementCancelHandler：在收到SIGINT信号后调用此函数，终止正在进行的查询操作。
	die：该函数处理SIGTERM信号，用来终止当前事务。
	quickdie：处理SIGQUIT信号。先屏蔽其他信号，然后结束正在进行的工作并退出。
	handle_sig_alarm：该函数处理SIGALRM信号，这是由进程等待锁时间超时引发的。

2.6.4 初始化Postgres的运行环境
	首先调用BaseInit函数来完成基本初始化，之后调用InitPostgres来完成Postgres的初始化。分成两个阶段是因为与XLog相关的初始化必须在InitPostgres之前。

	
2.6.5 创建内存上下文并设置查询取消跳跃点
	首先创建一个名为MessageContext的内存上下文，该内存上下文用于存储从前端发送来的消息查询命令，以及在查询过程中的中间数据，每当PostgresMain进行下一次循环时该内存上下文会被重设

2.6.6 循环等待处理查询
	共享缓冲区PqSendBuffer：8192字节的输出缓冲区
	共享缓冲区PqRecvBuffer：8192字节的输入缓冲区
	Postgres使用一种基于消息的协议用于服务器和客户端之间的通信。
	在进入第一次循环时，服务进程首先会释放上次查询时的内存，并为新的查询分配内存。

2.6.7 简单查询的执行流程
	编译器：扫描用户输入的字符形式的命令，检查器合法性，并将其转换成Postgres定义的内部数据结构（语法树）。
	分析器：进行语义分析，生成统一的数据结构Query
	优化器：检查所有可行的查询计划，最终选择最快的执行查询计划，输出执行计划，
	执行器：执行查询命令

2.7 本章小结
	这一章从宏观上对PostgreSQL的控制和处理流程进行了简单的了解，说明各个模块之间是如何协同工作的。
