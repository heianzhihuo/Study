第4章 索引

4.1 概述

4.1.1 索引的方式
	唯一索引、主键索引、多属性索引、部分索引

4.1.2 索引类型
	1）B-Tree：涉及比较操作符<、>、=
	2）Hash：对索引关键字进行散列，涉及=操作
	3）GiST：GiST（Generalized Search Tree）通用索引树，是一种架构或者索引模板，在这种架构（模板）上实现不同的索引策略。
	4）GIN：GIN（Generalized Inverted Index）倒排索引，可以处理包含多个键的值。

4.1.3 索引相关的系统表
	
	每种索引类型都在系统表pg_am（access method）里面用一个元组来记录。目前该表中只有4个元组。
	对于每一个创建的索引都会在系统表pg_class系统表中添加一个元组，同时还会在系统表pg_index中添加一个元组。pg_index用于记录与索引有关的信息。
	每一种索引并不直接设定该类型的索引所要操作的数据类型，而是由操作符类型系统表pg_opclass进行管理。
	在pg_opclass中，每一个操作符类都引用了系统表pg_opfamily中的一个元组，表名该操作符类的操作集合。
	pg_opclass和pg_opfamily系统表都没有指定索引方法对各种数据类型的具体操作函数，这些信息保存在相关的系统表pg_amop和pg_amproc中。pg_amop存储每个索引操作符集合（pg_opfamily）与具体操作符（pg_operator）的关联信息.

4.1.4 索引的操作函数
	不同索引的操作函数并不相同，最多可以有13个操作函数。
	每一种索引类型可以实现ambuild、aminsert、ambulkdelete、amvacuumcleanup、amcostestimate、amoptions、ambeginscan、amgettuple、amgetbitmap、amrescan、amendscan、ammarkpos、amrestrpos共13个函数，会有相应的13个函数来实现这些接口。

4.2 B-Tree索引
	PostgreSQL的B-Tree索引是在论文p650-lehman.pdf的基础上的
	其结构类似B+树，它的结构特点为：
	a、B+树所有的关键字均在叶子节点中出现，并按关键字排序以顺序链的方式连接，同时，叶子结点还保存了指向相应记录的指针
	b、所有非叶子结点可以看成是索引的部分，并不指向实际的存储位置；非叶仅仅包含其子树结点的最小关键字。

4.2.1 B-Tree索引的组织结构
	索引也是按照页面结构进行存储
	每层非最右结点需要一个最大关键字（High-key），High-key并不是真正的关键字，它只是给出该结点中索引关键字的范围。
	当填充完一个页面后会进行调整。最右节点和非最右结点结构不一样。
	非最右结点用linp0来保存页面中的High-key，但是去掉指向itup3的链接。
	最右节点的所有linp都递减一个位置，linp3不再使用。
	指向左右兄弟的指针在Special space中保存，其中存放了一个BTPageOpaqueData的结构。

4.2.2 B-Tree索引的操作
	
	1、索引的创建
	首先对每一个需要索引的表元组生成对应的索引元组，然后调用tuplesort函数对所有的索引元组进行排序，最后创建索引。
	索引元组是一个索引结构的基本单位，由IndexTupleData表示。
	在将表元组封装成索引元组（索引项）的过程中，会生成一个BTBuildState结构用于保存索引元组。
	每一个BTree索引都有一个元页（metadataPage），它主要说明该B-Tree索引的版本、根结点位置一个根结点在树中的层次等信息，元页时钟位于BTree索引的第一页（编号为0）。
	元页用BTMetaPageData结构表示。
	创建一个BTree索引，首先会生成一个BTWrite的结构，它用于记录整个索引创建过程中的信息。
	在创建BTree索引时，对于树结构的每一层都会生成一个结构BTPageState。
	对于每一层的所有页面，只有一个BTPageState结构。每填充完一个页面，会申请一个新的页面，这时BTPageState结构随即更新为新页面中的信息。
	创建索引的入口函数是btbuild。

	2、插入索引元组
	当表中有新的元组插入时，索引也需要进行相应的更新，也就是将新插入的元组封装成索引元组并插入到索引中，这个过程由btinsert函数完成。
	该函数首先将表元组封装为索引元组，然后沿着BTree往下找到合适的插入节点。
	再查找合适节点的过程中，会使用结构BTStackData来保存查找过程中的父节点。
	在插入过程中还应考虑插入元组后节点分裂的问题。如果该节点需要进行分裂，则需要在节点中找到合适的分裂位置。在PostgreSQL中规定，如果该节点为该层中的最右结点，那么分裂后产生的右节点的剩余空间最好是分裂产生的左节点剩余空间的2倍；否则分裂产生的两个节点的剩余空间最好相等。
	在分裂节点过程中会生成FindSplitData结构，它用来记录寻找节点分裂位置时相关信息，特别是节点的最佳分裂位置以及待插入的新元组的相关信息。
	
	3、扫描索引
	btgettuple函数：得到扫描中的下一个满足条件的索引元组。
	btbeginscan函数：开始索引扫描。
	btrescan函数：重新扫描索引。
	btendscan函数：释放一个索引扫描占用的系统资源
	btmarkpos函数：保存当前扫描位置的相关变量
	btrestrpos函数：将用btmarkpos中所存储的扫描位置信息，导入到当前扫描位置信息中，从而恢复到上一次扫描的位置开始扫描。

	4、删除索引元组
	删除表中一个元组后，系统并不会立即删除该表元组对应的索引元组，而是在VACUUM的时候删除。


4.3 Hash索引
	
	1）静态Hash表：桶数目B不变
	2）动态Hash表：允许B改变。
	动态Hash表可分为两种：可扩展Hash表和线性Hash表

	PostgreSQL系统中使用的是动态Hash表，桶的个数随着分裂次数的增加而增加，但每次分裂后，所有增加的桶并不会立即使用，而只是使用需要存入元组的桶，其他新增的桶会被保留。

4.3.1 Hash索引的组织结构
	有两种类型的Hash表：用作索引的外存Hash表，用于内部数据查找的内存Hash表。本节对前者进行分析，它采用的是线性Hash表的一个实现。
	在Hash表中，有四种不同类型的页面，分别为元页、桶页、溢出页、位图页。Hash索引的页面结构和BTree索引节点的页面机构相同。对于页面末尾的Special Space，Hash索引填充的是HashPageOpaqueData结构。

	1、元页
	每个Hash索引都有元页，它是该索引的0号页。
	元页记录了Hash索引的基本信息，每次对Hash索引进行读写操作时都要将元页读入内存，并对其进行更新。
	2、桶页
	Hash表由多个桶组成，每个桶由一个或多个页组成，每个桶的第一页称为桶页，其他页称为溢出页，桶页随着桶的建立而建立。
	桶页是成组分配的每次分配都是2的幂次。每次分配的桶页在磁盘上都是连续存储的。
	3、溢出页
	如果某个元组在它所属的桶中放不下时，就需要给该桶增加一个溢出页。溢出页和桶页之间时通过双向链接链接起来的，即每一页都记录了前一页的块号和后一页的块号，这个双向链接保存在HashPageOpaqueData结构中。
	4、位图
	位图用于管理Hash索引的溢出页和位图页本身的使用情况。如果某个溢出页上的元组都被移出或删除，就要将此溢出页回收，但并不把它还给操作系统，而是继续由PostgreSQL管理，以便下次使用。
	在位图里，对于每一个溢出页和位图页都有一个比特为标识其使用情况，0表示该页可用，1表示该页不可用，可以把这些0、1位看做一个数组。
	位图页格式和图4-5不同，位图中不包含任何元组，页头为PageHeaderData，页尾有Special Space。位图的页头和页尾中间的部分就是位数组，每一位对应一个溢出页或位图。位图中所含位的数目必须是2的整数幂。

4.3.2 Hash索引的实现

	1、Hash表的构建
	构建Hash索引时，首先初始化该索引的元页、桶以及位图页。之后调用扫描函数对待索引的表进行扫描，生成对用的索引元组，最后将这些索引元祖插入到Hash表中。
	创建索引时用的是hashbuild函数，该函数用到的几个子函数如下：
	1）函数_hash_metapinit，该函数初始化hash表，其中包含一个元页、N个桶以及一个位图，最后返回初始化化的桶数目N，其中N为2的k次方。无需锁机制。
	2）函数IndexBuildHeapScan，该函数扫描整个基表，根据查找键对其中的每一个元组都生成一个Hash元组，并插入到Hash表中。在其中还将调用函数hashbuildCallback。
	3）函数hashCallback：生成Hash索引元组，并将其插入到Hash表中

	2、元组的插入
	函数_hash_doinsert。系统首先读取元页中的相关信息，计算出该索引元组应插入的桶号，若该桶有足够的空间，则将元组插入到该桶中；否则申请溢出页并插入到溢出页中。完成插入后，系统会再次根据元页的信息来判断是否需要增加新的桶。

	3、溢出页的分配与回收
	1）_hash_addovflpage：当要插入的元组在所属的桶链上找不到足够空间时，就要增加溢出页。
	2）函数_hash_getovflpage，该函数获取一个溢出页，并返回它在磁盘中的块号。
	3）函数_hash_freeovflpage：该函数将断开桶链，释放某个溢出页，并在位图中将其标记为可用。

	4、Hash表的扩展
	每次插入后，都用当前记录总数r和当前桶的书目n相除，计算r/n，若比率太大，就对表进行扩展，即增加一个桶到Hash表中，新增加的桶和发生插入的桶之间没有任何必然的联系。
	1）函数_hash_expandtable：该函数试图增加一个新桶来扩展Hash表。
	2）函数_hash_splitbucket：该函数将桶号为obucket的旧桶中的一部分元组分裂到桶号为nbucket的新桶里。
	3）函数_hash_squeezebucke：该函数压缩桶中的元组，使桶中的元组更加紧凑。


4.4 GiST索引

	GiST是一种平衡的、树状结构的访问方法，它在系统中相当于一个基础模板，几乎可以用它实现任意索引模式。BTree、RTree和许多其他的索引模式都可以用GiST实现。

4.4.1 GiST索引的扩展性
	
	GiST可以建立一种可扩展的索引结构，包括数据类型和查询谓词的扩展。

4.4.2 GiST索引的组织结构
	GiST是一棵平衡数，除根结点的子树数目在2-M之间外，每个节点的子树数目在k*M-M之间，常量k称作该树的最小填充因子，满足2/M<=k<=1/2，M为一个结点可以容纳索引项的最大数目。
	索引项的形式为(p,ptr)，其中p是搜索的谓词。在叶子节点中，ptr为指向数据库中的某一个元组的指针；而在非叶子结点中，ptr为指向其子树结点的指针。
	1）Consistent(E,q)：对于给定的索引项E(p,ptr)和查询谓词q，判断索引项E是否与查询谓词q匹配，若肯定不匹配，则返回假；否则，返回真。
	2）Union(P)
	3）Same(E1,E2)
	4）Penalty(E1,E2)
	5）PickSplit(P)
	6）Compress(E)
	7）Decompress(E)

4.4.3 GiST索引的实现
	
	1、GiST索引的创建由函数gistbuild完成。
	在创建索引过程中，索引元组的插入在函数gistdoinsert中完成。
	在插入索引元组过程中，会生成一个类型为GISTInsertStack的栈结构，用于记录当插入节点及其父节点的相关信息。
	2、GiST索引查询
	与BTree类似按深度优先原则自上而下进行检索。
	GiST索引查询主要通过函数gistnext来实现，该函数通过从上往下搜索索引结构。在扫描过程中会生成类型为GISTSearchStack栈结构。
	3、GiST索引删除
	当表元组删除时，并不立即删除其索引，而是在VACUUM操作来批量删除无效索引元组。

4.4.4 GiST索引实例



4.5 GIN索引
	
4.5.1 GIN索引的扩展性
	
	一个GIN索引需要实现的5个方法：
	1）compare方法
	2）extractValue方法
	3）extractQuery方法
	4）consistent方法
	5）comparePartial方法
	
	


























	

